<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Http on Deathdealer-Archives</title>
    <link>https://xiongchen2012.github.io/tags/http/</link>
    <description>Recent content in Http on Deathdealer-Archives</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>This site is generated by &lt;a href=&#39;http://gohugo.io&#39; style=&#39;color:rgb(95, 191, 94);&#39;&gt;HUGO&lt;/a&gt; with a theme &lt;a href=&#39;https://github.com/laozhu/hugo-nuo&#39; style=&#39;color:rgb(95, 191, 94);&#39;&gt;HUGO-NUO&lt;/a&gt; © deathdealer.cn</copyright>
    <lastBuildDate>Thu, 19 Jul 2018 10:08:16 +0800</lastBuildDate>
    
	<atom:link href="https://xiongchen2012.github.io/tags/http/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Js Object Properties</title>
      <link>https://xiongchen2012.github.io/post/js-object-properties/</link>
      <pubDate>Thu, 19 Jul 2018 10:08:16 +0800</pubDate>
      
      <guid>https://xiongchen2012.github.io/post/js-object-properties/</guid>
      <description>Javascript对象属性 属性的分类 Javascript对象的属性有3种类型：
1. 命名数据字段（Named Data Property） 2. 命名存取器字段（Named Accessor Property） 3. 内置字段（Internal Property）
命名数据字段（Named Data Property） 命名数据字段是JS对象最常见的属性，平时我们大部分时间接触和使用的都是这种类型的字段。它是名称(Key)和值(Value)的映射，一般形式是：
let obj = { key: value } //访问这类属性的值的方法有以下2种 console.log(obj.key); console.log(obj[key]); //设置这类属性的值的方法也有2种 obj.key = value; obj[key] = value;  命名存取器字段（Named Accessor Property） 除了上面两种给属性设置值的方法之外，还可以通过函数进行属性的赋值和取值。这种函数又叫存取器（Java里面又叫Getter和Setter）。这些存取器函数本身也是对象的属性之一，所以又叫命名存取器，一般形式是：
let obj = { get key(){ return value; }, set key(value){ key = value } } //调用方法和第1种是相同的。  内置字段（Internal Property） JS对象还有一些属性是ECMAJavascript规范规定的，也只有规范会用到这些属性，这些属性是无法直接访问到的，但是又确实影响了对象的行为，因此才管这些属性叫“内置”属性。
内置属性的特征是用两个方括号围起来的，比如[[Prototype]]属性用来指示对象的prototype,你没办法使用obj.[[ProtoType]]来访问这个属性的值，但是你可以通过Object.getPrototypeOf()来访问。
同时，你也没办法直接指定这种属性的值，比如说还是[[Prototype]]，直接使用obj.[[Prototype]]=something给它赋值肯定是不行的，但是你可以用Object.create()来赋值或者指定对象的__prototype__属性来赋值
另外一个例子是[[Extensible]]内置属性，用于标记对象能否扩展它的属性（添加新的字段）。只能通过Object.isExtensible()来访问，或者是通过Object.preventExtensions()来将其设置为false,一旦设置成false，就不能再设置成true了，因为没有提供叫类似Object.allowExtensions()这样的方法。
参考 Object properties in JavaScript</description>
    </item>
    
    <item>
      <title>深入分布式缓存读书笔记（3） - HTTP Cache</title>
      <link>https://xiongchen2012.github.io/post/http-cache/</link>
      <pubDate>Sun, 04 Feb 2018 10:17:48 +0800</pubDate>
      
      <guid>https://xiongchen2012.github.io/post/http-cache/</guid>
      <description>《深入分布式缓存》读书笔记
（1）缓存简介
（2）页面缓存（Application Cache）
（3）HTTP缓存  （4）代理服务器缓存
浏览器缓存（HTTP缓存） 和ApplicationCache相似，HTTP缓存的目标也是为了让浏览器使用本地缓存，而不去向服务器请求。
浏览器通过和服务器事先的约定来决定是否使用保存在浏览器本地的缓存，这个约定就是HTTP协议。协议里规定Client和Server协商使用缓存通过协议头（Header）来进行的，也就是传说中的 夹带私货
有多种Http Cache Headers，下面一一介绍：
Expires 服务器在返回给浏览器的响应头（Response Header）中夹带返回访资源过期的时间，比如： Expires: Sat, 2 Feb 2018 23:59:59 GMT
翻译成人话：当前这一资源将于2018年2月3日 23时59分59秒过期。在这之前浏览器您可以放心使用本地缓存，过了这个时间您就需要再向服务器请求了。
适用于：HTTP1.0、HTTP1.1
缺点：缺点很明显，服务器时间不一定和客户端时间一致啊！！
Cache-Control 为了解决Expires的问题，引进了Cache-Control，服务器返回一个相对的秒数，表示从这个资源下载完成的时间算起，N秒内都可以放心将其放到缓存中使用。N秒后浏览器才需要重新下载。 Cache-Control: max-age=3600
翻译成人话：当前页面有效期为3600秒，这段时间内你可以直接使用这个页面无需重新下载。过了3600秒后，你就需要重新向服务器请求了。
适用于：HTTP1.1
Last-Modified / If-Modified-Since 浏览器在第1次请求资源时，如果服务器返回200，响应头里面一般会有一个Last-Modified字段，字段的值服务器最后一次修改此资源的时间。 Last-Modified: Sat, 2 Feb 2018 18:39:13 GMT
当浏览器再次请求该资源时，会在请求头里夹带一个If-Modified-Since的私货，内容就是第1次服务器返回的那个最后修改时间。这个过程是浏览器向服务器询问当前请求的资源自从最后一次修改以后是否又进行过修改？ If-Modified-Since: Sat, 2 Feb 2018 18:39:13 GMT
服务器收到请后，发现这段时间内没有再修改该资源，就返回状态码304（Not Modified），请示我没有修改过该资源，浏览器你可以使用你的本地缓存。
ETag / If-None-Match (TO BE CONTINUED)</description>
    </item>
    
  </channel>
</rss>