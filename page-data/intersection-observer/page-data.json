{"componentChunkName":"component---src-templates-blog-post-js","path":"/intersection-observer/","result":{"data":{"site":{"siteMetadata":{"title":"Deathdealer's Blog"}},"markdownRemark":{"id":"49de1097-c907-55d0-b1de-caca2b3397ee","excerpt":"什么是曝光埋点 如果需要衡量流量的分发效率，或者需要衡量活动对用户的吸引力时，会涉及到一个点击效果的量化指标：点击率（CTR…","html":"<h4>什么是曝光埋点</h4>\n<p>如果需要衡量流量的分发效率，或者需要衡量活动对用户的吸引力时，会涉及到一个点击效果的量化指标：点击率（CTR），点击率的计算公式如下所示：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token constant\">CTR</span> <span class=\"token operator\">=</span> 点击数 <span class=\"token operator\">/</span> 曝光数</code></pre></div>\n<p>点击数通过点击事件埋点很容获得，但是分母就比较困难了。如果直接采用页面的浏览次数作为分母，明显是不科学的，因为很可能活动区域用户压根就没看见或是看见了并没有停留。想要获取分母的数据，要用到本文所说的曝光埋点。<code class=\"language-text\">曝光埋点</code>用来统计页面某个区域被用户<code class=\"language-text\">看到</code>的次数，此外一般还需要加上有效浏览的限制，即该区域至少需要停留时长5秒以上。</p>\n<h4>传统方法</h4>\n<p>监听<code class=\"language-text\">scroll</code>事件，然后调用目标区域的<a href=\"https://developer.mozilla.org/en/docs/Web/API/Element/getBoundingClientRect\"><code class=\"language-text\">getBoundingClientRect()</code></a>方法，得到它相对于<code class=\"language-text\">viewport</code>的坐标，再判断是否在<code class=\"language-text\">viewport</code>之内。这种方法比较简单，但是有个致命缺点，事件监听和调用 <code class=\"language-text\">getBoundingClientRect()</code> 都是在主线程上运行，因此频繁触发、调用可能会造成性能问题。用防抖来优化又极易造成在防抖的<code class=\"language-text\">timeout</code>时间段内目标区域脱离。所以传统的做法极其怪异且不优雅。</p>\n<h4>Observer API实现</h4>\n<h5><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver\">IntersectionObserver</a></h5>\n<blockquote>\n<p><code class=\"language-text\">IntersectionObserver</code><strong>接口</strong> (从属于<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\">Intersection Observer API</a>) 提供了一种异步观察目标元素与其祖先元素或顶级文档视窗(<a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Viewport\">viewport</a>)交叉状态的方法。祖先元素与视窗(<a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Viewport\">viewport</a>)被称为<strong>根(root)。</strong></p>\n</blockquote>\n<p>这里所谓的<strong>交叉状态</strong>就是指和视口产生了交集，由于可见的本质就是目标元素与视口产生一个交叉区，所以这个 API又叫<code class=\"language-text\">交叉观察器</code>，可以简单且高性能的监视元素是否出现。</p>\n<p><strong>兼容性</strong></p>\n<p> 除IE之外（不出所料），现代浏览器已经全部很好的支持了<code class=\"language-text\">IntersectionObserver</code></p>\n<img src=\"https://obs-1d2f.oss-cn-hangzhou.aliyuncs.com/images/image-20210728105459323.png\" alt=\"image-20210728105459323\" style=\"zoom:50%;\">\n<p><strong>优点</strong></p>\n<ul>\n<li><strong>异步处理</strong>消除了昂贵的DOM样式查询和连续的轮询；</li>\n<li>API配置丰富，可以实现除曝光埋点以外各种需要判断元素可见性的需求；</li>\n</ul>\n<p><strong>概念和用法</strong></p>\n<p><code class=\"language-text\">IntersectionObserver</code>的基本用法是注册一个回调函数，当以下条件满足时调用该回调函数：</p>\n<ul>\n<li>目标元素与<code class=\"language-text\">viewport</code>或者指定的元素产生交集时；</li>\n<li>IntersectionObserver第一次监听元素时；</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 创建IntersectionObserver对象，需要传入相应参数和回调用函数</span>\n<span class=\"token keyword\">const</span> observer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IntersectionObserver</span><span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 指定目标元素</span>\n<span class=\"token keyword\">const</span> target <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#advertisment'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 监听目标元素</span>\nobserver<span class=\"token punctuation\">.</span><span class=\"token function\">observe</span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>选项(options)</strong></p>\n<ul>\n<li>\n<p><strong>root</strong></p>\n<p>指定根元素，用于检查目标的可见性。必须是目标元素的父级元素。如果未指定或者为<code class=\"language-text\">null</code>，则默认为浏览器视窗。</p>\n</li>\n<li>\n<p><strong>rootMargin</strong></p>\n<p>根(<strong>root</strong>)元素的外边距。类似于 CSS 中的  <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin\"><code class=\"language-text\">margin</code></a> 属性，比如 ”<code class=\"language-text\">10px 20px 30px 40px&quot;</code> (top, right, bottom, left)。如果有指定root参数，则rootMargin也可以使用百分比来取值。该属性值是用作root元素和target发生交集时候的计算交集的区域范围，使用该属性可以控制root元素每一边的收缩或者扩张。默认值为0。</p>\n<img src=\"https://obs-1d2f.oss-cn-hangzhou.aliyuncs.com/images/image-20210728144424498.png\" alt=\"image-20210728144424498\" style=\"zoom:50%;\">\n</li>\n<li>\n<p><strong>threshold</strong></p>\n<p>可以是单一的<code class=\"language-text\">number</code>也可以是<code class=\"language-text\">number数组</code>，target元素和root元素相交程度达到该值的时候<code class=\"language-text\">IntersectionObserver</code>注册的回调函数将会被执行。如果你只是想要探测当target元素的在root元素中的可见性超过50%的时候，你可以指定该属性值为0.5。如果你想要target元素在root元素的可见程度每多25%就执行一次回调，那么你可以指定一个数组[0, 0.25, 0.5, 0.75, 1]。</p>\n<p>默认值是<code class=\"language-text\">0</code>(意味着只要有一个target像素出现在root元素中，回调函数将会被执行)。该值为<code class=\"language-text\">1.0</code>含义是当target完全出现在root元素中时候 回调才会被执行。</p>\n</li>\n</ul>\n<p><strong>回调函数(callback)</strong></p>\n<p>回调函数接收 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserverEntry\"><code class=\"language-text\">IntersectionObserverEntry</code></a> 对象和观察者的列表：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> <span class=\"token function-variable function\">callback</span> <span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">entries<span class=\"token punctuation\">,</span> observer</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>boundingClientRect</td>\n<td>目标元素的边界信息，返回结果与<code class=\"language-text\">getBoundingClientRect</code> 相同</td>\n</tr>\n<tr>\n<td><strong>intersectionRatio</strong></td>\n<td>目标元素出现在可视区的比例</td>\n</tr>\n<tr>\n<td><strong>isIntersecting</strong></td>\n<td>1. 如果目标元素出现在root可视区，返回true。<br>2. 如果目标元素从root可视区消失，返回false</td>\n</tr>\n<tr>\n<td>intersectionRect</td>\n<td>root和目标元素的相交区域</td>\n</tr>\n<tr>\n<td>rootBounds</td>\n<td>交叉区域观察器(intersection observer)中的根.</td>\n</tr>\n<tr>\n<td>target</td>\n<td>目标元素</td>\n</tr>\n<tr>\n<td>time</td>\n<td>记录从 IntersectionObserver 的时间原点到交叉事件被触发的时间</td>\n</tr>\n</tbody>\n</table>\n<p>表格中加粗的两个属性是比较常用的判断条件：<strong>isIntersecting</strong>和<strong>intersectionRatio</strong></p>\n<p>注意：回调函数将会在主线程中被执行。所以该函数执行速度要尽可能的快。如果有一些耗时的操作需要执行，建议使用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback\"><code class=\"language-text\">Window.requestIdleCallback()</code></a> 方法。</p>\n<p><strong>其它API</strong></p>\n<ul>\n<li>\n<p>unobserve()</p>\n<p>停止对指定目标元素的监听</p>\n</li>\n<li>\n<p>takeRecords()</p>\n<p>返回所有观察目标的IntersectionObserverEntry对象数组</p>\n</li>\n<li>\n<p>disconnect()</p>\n<p>使<code class=\"language-text\">IntersectionObserver</code>对象停止全部监听工作</p>\n</li>\n</ul>\n<h4>扩展应用</h4>\n<p>除了曝光埋点之外，交叉检测可以轻送实现以前很复杂的功能，如下：</p>\n<ul>\n<li>图片懒加载（LazyLoad）——当图片滚动到可见时才进行加载</li>\n<li>内容无限滚动（Infinity Scroll）——当用户滚动到接近内容底部（触底）时直接加载更多，而无需用户操作翻页，给用户一种网页可以无限滚动的错觉</li>\n<li>在用户看见某个区域时执行任务或播放视频等，当用户划走时开启小窗继续播放或停止播放。</li>\n<li>吸顶 —— 如果用css的<code class=\"language-text\">position: sticky</code>实现兼容性比较差。</li>\n</ul>\n<h5>Polyfill</h5>\n<p>如里需要在IE中兼容<code class=\"language-text\">IntersectionObserver</code>，需要引入<a href=\"https://github.com/w3c/IntersectionObserver/tree/main/polyfill\">W3C官方Polyfill</a></p>","frontmatter":{"title":"前端埋点之曝光埋点","date":"2021/07/28 09:52:44","description":"曝光埋点用来统计页面某个区域被用户“看到”的次数，此外一般还需要加上有效浏览的限制，即该区域至少需要停留时长5s以上"}},"previous":{"fields":{"slug":"/data-analysis-track/"},"frontmatter":{"title":"前端埋点之数据上报方式"}},"next":{"fields":{"slug":"/ssr-ssg-isr-dpr/"},"frontmatter":{"title":"SSR、SSG、ISR、DPR简介"}}},"pageContext":{"id":"49de1097-c907-55d0-b1de-caca2b3397ee","previousPostId":"d481b88f-0e5a-547b-a405-15bb8625037f","nextPostId":"b3b1ebf9-6cf4-565e-841f-2c71bc9c6879"}},"staticQueryHashes":["2355076697","2841359383"]}