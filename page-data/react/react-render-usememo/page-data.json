{"componentChunkName":"component---src-templates-blog-post-js","path":"/react/react-render-usememo/","result":{"data":{"site":{"siteMetadata":{"title":"Deathdealer's Blog"}},"markdownRemark":{"id":"3e7614a4-2bc6-508c-b7c0-097796d4a86c","excerpt":"原文地址 快速示例： 子组件被 包裹，传递一个给它用于控制是否显示一个侧边栏（当用户的角色更新为”Admin…","html":"<blockquote>\n<p><a href=\"https://alexsidorenko.com/blog/react-render-usememo/\">原文地址</a></p>\n</blockquote>\n<p>快速示例：</p>\n<p>子组件被 <code class=\"language-text\">memo</code>包裹，传递一个<code class=\"language-text\">options</code>给它用于控制是否显示一个侧边栏（当用户的角色更新为”Admin”时，<code class=\"language-text\">showSidebar=true</code>否则为<code class=\"language-text\">false</code>）。但从下图的效果来看，即使只是改变了用户名，子组件依然发生了重新渲染。如何防止这种情况的发生？</p>\n<p><video style=\"aspect-ratio: 1360/822\" autoplay=\"\" loop=\"\" muted=\"\" playsinline=\"\" src=\"https://alexsidorenko.com/92b145bc405d8dd2f12ae45da9ee550d/quiz.mp4\"></video></p>\n<p>是不是应该在计算 <code class=\"language-text\">showSidebar</code> 外面使用 <code class=\"language-text\">useMemo</code> ？且往下看</p>\n<h3>这是一个陷阱！</h3>\n<p>对不起，上面是一个蓄意误导的示例，简化一下来看为什么。</p>\n<p><video style=\"aspect-ratio: 1360/743\" autoplay=\"\" loop=\"\" muted=\"\" playsinline=\"\" src=\"https://alexsidorenko.com/8312f160f6f8b92f2e3d04f508d3df5b/simple.mp4\"></video></p>\n<p>即使直接将 <code class=\"language-text\">showSidebar</code>的值写死为<code class=\"language-text\">true</code>，子组件仍旧会重新渲染。这是因为 <code class=\"language-text\">options prop</code> 是一个对象，从之前一篇Blog可知memo比较的是对象的引用而不是值。因此子组件会无视我们如何计算<code class=\"language-text\">showSidebar</code>的值，且始终会触发重新渲染，因为 <code class=\"language-text\">options !== options</code>。有两种方法可以防止这种情况的发生。</p>\n<h3>1. 拍平props</h3>\n<p>用<code class=\"language-text\">boolean</code>类型的变量 <code class=\"language-text\">showSidebar</code> 来存储原始值，当把 <code class=\"language-text\">showSidebar</code> 替代<code class=\"language-text\">optoins</code>直接传递给子组件时, 只有当这个<code class=\"language-text\">boolean</code>值发生变化时子组件才会触发重新渲染。</p>\n<p><video style=\"aspect-ratio: 1360/823\" autoplay=\"\" loop=\"\" muted=\"\" playsinline=\"\" src=\"https://alexsidorenko.com/edd48000cdcb5d67252623f4c095ecd4/flatten.mp4\"></video></p>\n<p>但有的时候你确实需要传入一个<code class=\"language-text\">object prop</code>，可能是因为架构要求这样做，也可能是在使用一个第三方的组件，当你别无选择的时候，应该怎么做？</p>\n<h3>2. useMemo</h3>\n<p>记住，能够提供完全相同引用的最简单方法，就是在React组件名部定义一个非原始类型的变量（在上一篇Blog中有提到）</p>\n<p>但是在我们的这个示例中，我们没办法在React组件外部去定义 <code class=\"language-text\">options</code> ，因为它依赖于组件的<code class=\"language-text\">state</code>。这种情况下，我们可以利用 <code class=\"language-text\">useMemo</code>。 <code class=\"language-text\">useMemo</code>会缓存它的计算结果而不是每次render时都返回一个新的值, 它会返回旧的缓存的值，对于非原始类型来说总是会返回相同的对象引用。</p>\n<p><video style=\"aspect-ratio: 1360/817\" autoplay=\"\" loop=\"\" muted=\"\" playsinline=\"\" src=\"https://alexsidorenko.com/9d2a5243004f14006eb5418484af6068/no-dependencies.mp4\"></video></p>\n<p><code class=\"language-text\">options prop</code>接受使用<code class=\"language-text\">useMemo</code>缓存下来的值，所以子组件不会再重新渲染。新的问题出现了，现在 <code class=\"language-text\">options</code> prop即使更新用户<code class=\"language-text\">role</code>的值也不会发生变化。这是因为我们给<code class=\"language-text\">useMemo</code> 的第2个参数提供一个空的依赖列表（数组）</p>\n<h3>依赖列表</h3>\n<blockquote>\n<p>useMemo仅在依赖列表中的任意一个发生变化时，重新计算并更新缓存的值。这项优化帮助我们避免每次render时都进行一次高开销的计算。</p>\n<p><a href=\"https://zh-hans.reactjs.org/docs/hooks-reference.html#usememo\">React docs - useMemo</a></p>\n</blockquote>\n<p>因为我们提供了一个空的依赖列表，所以<code class=\"language-text\">useMemo</code> 不会在父组件重新渲染时重新计算<code class=\"language-text\">showSidebar</code>的值。可以通过将<code class=\"language-text\">user</code>对象添加到依赖列表中来修复这个问题，如下图所示：</p>\n<p><video style=\"aspect-ratio: 1360/823\" autoplay=\"\" loop=\"\" muted=\"\" playsinline=\"\" src=\"https://alexsidorenko.com/f56bff174cbf1c0f3c635b7ad2a4891e/user-dependency.mp4\"></video></p>\n<p>现在一切又回到了原点。当和子组件毫无关联的属性 <code class=\"language-text\">user.name</code> 更新时子组件也触发重新渲染。为了解决这个问题，需要清楚 <code class=\"language-text\">useMemo</code> 的依赖是如何工作的。</p>\n<p>每一次render <code class=\"language-text\">useMemo</code> 都会对依赖列表中的值进行浅比较(<code class=\"language-text\">prevDependency === dependency</code>)。如果任何一个依赖改变了，<code class=\"language-text\">useMemo</code>重新计算并更新缓存中的值。在之前的Blog中，简单介绍了 <code class=\"language-text\">memo</code>对原始类型和非原始类型值的浅比较机制，这一套机制对于 <code class=\"language-text\">useMemo</code>依然适用。</p>\n<img src=\"https://alexsidorenko.com/static/3ec74161aaa95ab8357540790cecb86d/f058b/usememo-dependencies.png\" alt=\"test\" style=\"zoom:80%;\">\n<p>示例中每一次状态的更新都是<code class=\"language-text\">immutable</code>的，意味着每次更新user对象的<code class=\"language-text\">role</code>或<code class=\"language-text\">name</code>属性，实际上是重新创建了一个新的对象。<code class=\"language-text\">useMemo</code>检测到 <code class=\"language-text\">prevUser !== user</code> ，所以进行了重新计算。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">updateName</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">name</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setUser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token operator\">...</span>user<span class=\"token punctuation\">,</span> name<span class=\"token operator\">:</span> name<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>请注意 <code class=\"language-text\">user.role</code>保存的是原始类型（string），就这意味着可以直接把它放到依赖列表中并且不用担心引用类型的比较。只有当<code class=\"language-text\">user.role</code> 的值更新了， <code class=\"language-text\">useMemo</code> 才会重新计算，如下图所示：</p>\n<p><video style=\"aspect-ratio: 1360/823\" autoplay=\"\" loop=\"\" muted=\"\" playsinline=\"\" src=\"https://alexsidorenko.com/42352d415e85a4ed08ef52bcc62f8e73/final.mp4\"></video></p>\n<h3>性能</h3>\n<p>这篇Blog中，我们探索了 <code class=\"language-text\">useMemo</code> 作为一种提供稳定的非原始类型<code class=\"language-text\">props</code>的工具。 有极少数场景下， React可能会选择性遗忘缓存的值即使依赖列表中的值没有发生变化。但是只要你因为性能优化的原因使用它，就不会有什么问题，即使 <code class=\"language-text\">useMemo</code> 重新计算缓存的值你的代码也能正常工作。在上面的示例中，即使React选择重新计算和缓存 <code class=\"language-text\">useMemo</code>，唯一无心发生的事也只是子组件重新渲染。</p>\n<blockquote>\n<p><strong>你可以把 <code class=\"language-text\">useMemo</code> 作为性能优化的手段，但不要把它当成语义上的保证。</strong>将来，React 可能会选择“遗忘”以前的一些 memoized 值，并在下次渲染时重新计算它们，比如为离屏组件释放内存。先编写在没有 <code class=\"language-text\">useMemo</code> 的情况下也可以执行的代码 —— 之后再在你的代码中添加 <code class=\"language-text\">useMemo</code>，以达到优化性能的目的。</p>\n<p><a href=\"https://zh-hans.reactjs.org/docs/hooks-reference.html#usememo\">React docs - useMemo</a></p>\n</blockquote>\n<p>另外，请记住你不需要修复每一处不必要的重新渲染。有时候<code class=\"language-text\">useMemo</code>的性能损耗会超过它带来的收益。可以参考这篇文章： <a href=\"https://kentcdodds.com/blog/usememo-and-usecallback\">When to useMemo and useCallback</a> （ Kent C. Dodds.）</p>","frontmatter":{"title":"React Rendering教程（3） - useMemo","date":"2021/08/23 22:55:23","description":"useMemo会缓存它的计算结果而不是每次render时都返回一个新的值, 它会返回旧的缓存的值，"}},"previous":{"fields":{"slug":"/react/react-render-props/"},"frontmatter":{"title":"React Rendering教程（2） - Props"}},"next":{"fields":{"slug":"/react/react-render-usecallback/"},"frontmatter":{"title":"React Rendering教程（4） - useCallback"}}},"pageContext":{"id":"3e7614a4-2bc6-508c-b7c0-097796d4a86c","previousPostId":"d14a5964-c266-527d-aa77-49405ca39a12","nextPostId":"24ac4511-3c67-5132-9b5f-fce15007bd48"}},"staticQueryHashes":["2355076697","2841359383"]}