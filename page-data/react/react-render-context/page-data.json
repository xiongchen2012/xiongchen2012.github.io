{"componentChunkName":"component---src-templates-blog-post-js","path":"/react/react-render-context/","result":{"data":{"site":{"siteMetadata":{"title":"Deathdealer's Blog"}},"markdownRemark":{"id":"9b3e7f3d-859d-5afe-b65d-0041bbc69c81","excerpt":"原文地址 当组件消费的时候，如果值变了，组件会重新渲染。但是下面的示例中为什么  and  也重新渲染了？  组件树的结构为  Context和Rendering 第一篇Blog中，我们了解了React Rendering的行为。当组件重新渲染时，React…","html":"<blockquote>\n<p><a href=\"https://alexsidorenko.com/blog/react-render-context/\">原文地址</a></p>\n</blockquote>\n<p>当组件消费<code class=\"language-text\">Context</code>的时候，如果<code class=\"language-text\">context</code>值变了，组件会重新渲染。但是下面的示例中为什么 <code class=\"language-text\">Component A</code> and <code class=\"language-text\">Component B</code> 也重新渲染了？</p>\n<p><video style=\"aspect-ratio: 1360/1121\" autoplay=\"\" loop=\"\" muted=\"\" playsinline=\"\" src=\"https://alexsidorenko.com/345403c36ea184fe348d0e3996725309/initial.mp4\"></video></p>\n<p>组件树的结构为 <code class=\"language-text\">App (ContextProvider) &gt; A &gt; B &gt; C</code></p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">App</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">AppContext.Provider</span></span> <span class=\"token attr-name\">...</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ComponentA</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">AppContext.Provider</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">ComponentA</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ComponentB</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">ComponentB</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ComponentC</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>Context和Rendering</h3>\n<p>第一篇Blog中，我们了解了React Rendering的行为。当组件重新渲染时，React会递归的重新渲染它的子组件， 并且会无视它们的<code class=\"language-text\">props</code>和<code class=\"language-text\">context</code>。如果把上面示例中的<code class=\"language-text\">context</code>移除掉会发什么，请看下面示例：</p>\n<p><video style=\"aspect-ratio: 1360/895\" autoplay=\"\" loop=\"\" muted=\"\" playsinline=\"\" src=\"https://alexsidorenko.com/d9096d3e51b8bf32d6ba597e91c2793e/no-context.mp4\"></video></p>\n<p>为了防止递归的重新渲染，我们可以使用<code class=\"language-text\">memo</code>，我们给一开始的示例再加上 <code class=\"language-text\">memo</code> </p>\n<p><video style=\"aspect-ratio: 1360/1127\" autoplay=\"\" loop=\"\" muted=\"\" playsinline=\"\" src=\"https://alexsidorenko.com/3347fc58a2f5a947c6cf4bba84244a4f/memo.mp4\"></video></p>\n<p>所以 👇</p>\n<img src=\"https://obs-1d2f.oss-cn-hangzhou.aliyuncs.com/images/image-20210824142052905.png\" alt=\"image-20210824142052905\" style=\"zoom:40%;\">\n<h3>Context 和引用</h3>\n<p>实际应用中，会经常通过<code class=\"language-text\">context</code>传递更多的数据。有时候数据会依赖某些<code class=\"language-text\">state</code>的变量</p>\n<p><video style=\"aspect-ratio: 1360/1195\" autoplay=\"\" loop=\"\" muted=\"\" playsinline=\"\" src=\"https://alexsidorenko.com/9e4b54f5eb5785ecff6c8bfd344f3439/text.mp4\"></video></p>\n<p>我们只把 <code class=\"language-text\">a</code> 和 <code class=\"language-text\">b</code>传递给了<code class=\"language-text\">Provider</code>，但当<code class=\"language-text\">count</code>更新时，消费的组件也重新渲染了。如何防止出现这种情况？</p>\n<p>提示： <code class=\"language-text\">text</code>是一个对象，它是非原始类型（non-primitive）</p>\n<blockquote>\n<p>所有的<code class=\"language-text\">Consumer</code>都是<code class=\"language-text\">Provider</code>的子孙节点，当<code class=\"language-text\">Provider</code>的<code class=\"language-text\">value</code>变化时，会重新渲染</p>\n<p><a href=\"https://reactjs.org/docs/context.html#contextprovider\">React Docs - Context Provider</a></p>\n</blockquote>\n<p>当 <code class=\"language-text\">count</code> 的值更新时，<code class=\"language-text\">App</code>组件重新渲染，导致 <code class=\"language-text\">text</code> 变量重新声明和赋值（变成一个新的变量）。我们现在已经知道了原始类型和引用类型的区别。 <code class=\"language-text\">{a: &quot;lorem&quot;, b: &quot;ipsum&quot;} !== {a: &quot;lorem&quot;, b: &quot;ipsum&quot;}</code>意味着每一次App重新渲染时，即使<code class=\"language-text\">a</code>和<code class=\"language-text\">b</code>的值没有变，<code class=\"language-text\">context</code>的值也会发生变化。因此<code class=\"language-text\">consumer</code>也重新渲染了。为了防止出现这种情况，我们需要保证 <code class=\"language-text\">text</code> 变量一直维持相同对象的引用。之前的Blog中有介绍，我们可以使用 <code class=\"language-text\">useMemo</code>，所下所示：</p>\n<p><video style=\"aspect-ratio: 1360/1195\" autoplay=\"\" loop=\"\" muted=\"\" playsinline=\"\" src=\"https://alexsidorenko.com/732fa2873e4805de5f45ae3e1dde6dca/usememo.mp4\"></video></p>\n<p>现在 <code class=\"language-text\">text</code> 变量只有在 <code class=\"language-text\">useMemo</code> 依赖列表（a和b）发生变化时，才会重新定义并赋值。 <code class=\"language-text\">count</code> 不在依赖列表中，所以即使<code class=\"language-text\">count</code> 变了， <code class=\"language-text\">text</code> 也不会发生任何变化，<code class=\"language-text\">consumer</code>也不会重新渲染。</p>","frontmatter":{"title":"React Rendering教程（5） - Context","date":"2021/08/24 15:06:41","description":"当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。"}},"previous":{"fields":{"slug":"/react/react-render-usecallback/"},"frontmatter":{"title":"React Rendering教程（4） - useCallback"}},"next":{"fields":{"slug":"/react/batched-update/"},"frontmatter":{"title":"如何获取正确的setState之后的值"}}},"pageContext":{"id":"9b3e7f3d-859d-5afe-b65d-0041bbc69c81","previousPostId":"24ac4511-3c67-5132-9b5f-fce15007bd48","nextPostId":"f41ac525-4945-50ec-896c-e2668bc386c0"}},"staticQueryHashes":["2355076697","2841359383"]}