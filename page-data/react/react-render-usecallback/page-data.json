{"componentChunkName":"component---src-templates-blog-post-js","path":"/react/react-render-usecallback/","result":{"data":{"site":{"siteMetadata":{"title":"Deathdealer's Blog"}},"markdownRemark":{"id":"24ac4511-3c67-5132-9b5f-fce15007bd48","excerpt":"原文地址 我们经常会把匿名函数作为事件处理器传递给React组件。即使子组件被包裹，也会引起子组件的重新渲染  JS…","html":"<blockquote>\n<p><a href=\"https://alexsidorenko.com/blog/react-render-usecallback/\">原文地址</a></p>\n</blockquote>\n<p>我们经常会把匿名函数作为事件处理器传递给React组件。即使子组件被<code class=\"language-text\">memo</code>包裹，也会引起子组件的重新渲染</p>\n<p><video style=\"aspect-ratio: 1360/665\" autoplay=\"\" loop=\"\" muted=\"\" playsinline=\"\" src=\"https://alexsidorenko.com/a74a21ec4b3136079f1597f02301f898/initial.mp4\"></video></p>\n<h3>JS中的函数</h3>\n<p>函数是一等公民</p>\n<blockquote>\n<p>当一门编程语言的函数可以被当作变量一样用时，则称函数是这门语言的<strong>一等公民</strong>。例如，在这门语言中，函数可以被当作参数传递给其他函数，可以作为另一个函数的返回值，还可以被赋值给一个变量。</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/First-class_Function\">MDN - First-class Function</a></p>\n</blockquote>\n<p>当这样传递一个匿名函数时，很容易忽略<code class=\"language-text\">onClick</code>仅仅只是组件的一个<code class=\"language-text\">prop</code>，而函数也仅仅只是这个<code class=\"language-text\">prop</code>的值。如果把函数赋值给一个变量时，会更容易看出这一点，如下图所示：</p>\n<p><video style=\"aspect-ratio: 1360/776\" autoplay=\"\" loop=\"\" muted=\"\" playsinline=\"\" src=\"https://alexsidorenko.com/22835a82687aab5f649e792f80720ac4/declare-function.mp4\"></video></p>\n<p>这种方式更加明显了，<code class=\"language-text\">handler</code>存储了<code class=\"language-text\">onClick</code> 的值（函数）。无论什么时候这个值变了，子组件都会重新渲染。函数是非原始类型，只会进行引用的比较。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">a</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">b</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\na <span class=\"token operator\">===</span> b <span class=\"token comment\">// false</span>\na <span class=\"token operator\">===</span> a <span class=\"token comment\">// true</span></code></pre></div>\n<p>父组件渲染时，<code class=\"language-text\">handler</code>实际上会重新声明并被赋上新的引用值，因此子组件也触重新渲染。想要防止这种情况，需要每次都给 <code class=\"language-text\">onClick</code> prop传递相同的引用，这时候我们需要记住并缓存 <code class=\"language-text\">handler</code>.</p>\n<h3>useCallback hook</h3>\n<p>之前的Blog中介绍了 <code class=\"language-text\">useMemo</code> 在每次render时是如何重新计算和缓存值的。 <code class=\"language-text\">useCallback</code> 和它本质上是完全一样的，唯一的区别是<code class=\"language-text\">useCallback</code>返回的是函数。</p>\n<blockquote>\n<p>useCallback(fn, deps) 等价于 useMemo(() => fn, deps).</p>\n<p><a href=\"https://zh-hans.reactjs.org/docs/hooks-reference.html#usecallback\">React Docs - useCallback</a></p>\n</blockquote>\n<p>所以，如果想要缓存<code class=\"language-text\">handler</code>的引用，只要把用 <code class=\"language-text\">useCallback</code>包裹一下就行了，先看下面的示例：</p>\n<p><video style=\"aspect-ratio: 1360/778\" autoplay=\"\" loop=\"\" muted=\"\" playsinline=\"\" src=\"https://alexsidorenko.com/3b1f1e02cc97c253db02a9169b9e9c38/empty-dependencies.mp4\"></video></p>\n<p>可以看到子组件不再重新渲染了，但是<code class=\"language-text\">count</code>不管你点多少次按钮只更新了1次。这也是依赖列表的原因。  <code class=\"language-text\">useMemo</code>和 <code class=\"language-text\">useCallback</code> 一样，只有在依赖列表中的项目发生变化时才会重新计算和更新缓存。 <code class=\"language-text\">handler</code> 在第1次render时会被缓存。由于闭包的存在，即使<code class=\"language-text\">count</code>发生了变化，记忆的函数引用的也是之前的<code class=\"language-text\">count</code>值。在上面的示例中，引用的<code class=\"language-text\">count</code>始终是<code class=\"language-text\">0</code>，因此 <code class=\"language-text\">count + 1</code> 始终是 <code class=\"language-text\">1</code>.</p>\n<blockquote>\n<p>如果你不知道啥是<code class=\"language-text\">闭包</code>，请参考这篇文档 - <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures\">MDN -Closures</a> 有很多消化的东西，请按需食用。一开始你可能很难理解闭包的概念，但理解闭包将给你React带来超能力。</p>\n</blockquote>\n<p>为了使<code class=\"language-text\">update</code>可以更新，可以把<code class=\"language-text\">update</code>放在依赖列表中。通过这种方法 <code class=\"language-text\">useCallback</code> 只要<code class=\"language-text\">count</code>变化时就会重新计算并返回一个持有最新词法作用域的 <code class=\"language-text\">handler</code> </p>\n<p><video style=\"aspect-ratio: 1360/778\" autoplay=\"\" loop=\"\" muted=\"\" playsinline=\"\" src=\"https://alexsidorenko.com/cfc69f54ded494e3a7753bd21946fa3d/count-dependency.mp4\"></video></p>\n<p>噗，又回到原点了。子组件也会一起跟着重新渲染，因为<code class=\"language-text\">handler</code>每次都会随着<code class=\"language-text\">count</code>的改变而更新。为了解决这个问题，可以使用<strong>函数式更新</strong>。</p>\n<h3>函数式更新</h3>\n<blockquote>\n<p>如果新的 state 需要通过使用先前的 state 计算得出，那么可以将函数传递给 <code class=\"language-text\">setState</code>。该函数将接收先前的 state，并返回一个更新后的值。</p>\n<p><a href=\"https://zh-hans.reactjs.org/docs/hooks-reference.html#functional-updates\">React Docs - Functional Updates</a></p>\n</blockquote>\n<p>下面是函数式更新的示例：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// State update</span>\n<span class=\"token function\">setCount</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// Functional state update</span>\n<span class=\"token function\">setCount</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">prevCount</span> <span class=\"token operator\">=></span> prevCount <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>函数式更新可以让我们把<code class=\"language-text\">count</code>从依赖列表中移除，而不用担心闭包的问题。函数 <code class=\"language-text\">handler</code> 不会随着<code class=\"language-text\">count</code>改变而重新计算，而且 <code class=\"language-text\">prevCount</code> 会始终引用最新的值。</p>\n<p><video style=\"aspect-ratio: 1360/837\" autoplay=\"\" loop=\"\" muted=\"\" playsinline=\"\" src=\"https://alexsidorenko.com/9401a1fb31656179d6294bf4ad068c2c/functional-update.mp4\"></video></p>\n<p>完美解决！</p>","frontmatter":{"title":"React Rendering教程（4） - useCallback","date":"2021/08/24 13:22:02","description":"我们经常会把匿名函数作为事件处理器传递给React组件。即使子组件被`memo`包裹，也会引起子组件的重新渲染"}},"previous":{"fields":{"slug":"/react/react-render-usememo/"},"frontmatter":{"title":"React Rendering教程（3） - useMemo"}},"next":{"fields":{"slug":"/react/react-render-context/"},"frontmatter":{"title":"React Rendering教程（5） - Context"}}},"pageContext":{"id":"24ac4511-3c67-5132-9b5f-fce15007bd48","previousPostId":"3e7614a4-2bc6-508c-b7c0-097796d4a86c","nextPostId":"9b3e7f3d-859d-5afe-b65d-0041bbc69c81"}},"staticQueryHashes":["2355076697","2841359383"]}