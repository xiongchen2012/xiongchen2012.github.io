{"componentChunkName":"component---src-templates-blog-post-js","path":"/react/react-render-always-rerenders/","result":{"data":{"site":{"siteMetadata":{"title":"Deathdealer's Blog"}},"markdownRemark":{"id":"700253a0-4f38-5231-93e4-c980b136bd11","excerpt":"原文地址 先上图：  先看上图 👆，APP的父子结构是： ，代码如下： 组件A，B，C没有任何和，但是当重新渲染时他们仍然是会重新渲染的。 在正常的渲染过程中，React不会在乎子组件的是不是变化了，它会无条件地重新渲染子组件，因为父组件重新渲染了。 Mark Erikson - A (Mostly…","html":"<blockquote>\n<p><a href=\"https://alexsidorenko.com/blog/react-render-always-rerenders/\">原文地址</a></p>\n</blockquote>\n<p>先上图：</p>\n<p><video style=\"aspect-ratio: 1360/740\" autoplay=\"\" loop=\"\" muted=\"\" playsinline=\"\" src=\"https://alexsidorenko.com/e683ce6a34ba9150a64731879649fb75/parent-rerender-new.mp4\"></video></p>\n<p>先看上图 👆，APP的父子结构是： <code class=\"language-text\">App &gt; A &gt; B &gt; C</code>，代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">App</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 只有App组件里维护了state</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ComponentA</span></span> <span class=\"token punctuation\">/></span></span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// A、B、C组件没有自己的state</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">ComponentA</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ComponentB</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">ComponentB</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">ComponentC</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>组件A，B，C没有任何<code class=\"language-text\">props</code>和<code class=\"language-text\">state</code>，但是当<code class=\"language-text\">App</code>重新渲染时他们仍然是会重新渲染的。</p>\n<blockquote>\n<p>在正常的渲染过程中，React不会在乎子组件的<code class=\"language-text\">props</code>是不是变化了，它会无条件地重新渲染子组件，因为父组件重新渲染了。</p>\n<p>Mark Erikson - <a href=\"https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/#standard-render-behavior\">A (Mostly) Complete Guide to React Rendering Behavior</a></p>\n</blockquote>\n<p>为了进一步演示上面的结论，我们给每个组件加上自己的<code class=\"language-text\">state</code>来跟踪这一行为。</p>\n<p><video style=\"aspect-ratio: 1360/740\" autoplay=\"\" loop=\"\" muted=\"\" playsinline=\"\" src=\"https://alexsidorenko.com/5026a216db461be8e241d5a23148ba0a/state-new.mp4\"></video></p>\n<p>当<code class=\"language-text\">C</code>组件的<code class=\"language-text\">state</code>变化时，只有<code class=\"language-text\">C</code>组件重新渲染。但是当<code class=\"language-text\">B</code>组件的<code class=\"language-text\">state</code>变化时， <code class=\"language-text\">B</code>和<code class=\"language-text\">C</code>都重新渲染了。<code class=\"language-text\">B</code>重新渲染是因为它的<code class=\"language-text\">state</code>更新了，而<code class=\"language-text\">C</code>的重新渲染则是因为它的父组件（B）重新渲染了。</p>\n<p>当<code class=\"language-text\">A</code>的<code class=\"language-text\">state</code>更新时<code class=\"language-text\">A</code>会重新渲染了。<code class=\"language-text\">B</code>的重新渲染则是因为<code class=\"language-text\">A</code>，最后<code class=\"language-text\">C</code>的重新渲染则是因为<code class=\"language-text\">B</code></p>\n<h3>如何避免重新渲染</h3>\n<p>在React中有好多方法可以避免不必要的<code class=\"language-text\">re-render</code>。本文会聚集于 <code class=\"language-text\">React.memo</code> 这种方式（其它方式将会在后续的文章中介绍）。如果你对 <code class=\"language-text\">memo</code>有兴趣，可以阅读一下丹大师的<a href=\"https://overreacted.io/before-you-memo/\">Before you memo()</a></p>\n<blockquote>\n<p>在这篇文章中也请记住这一点，我只会探索直接更新<code class=\"language-text\">state</code>或是父组件更新而导致的重新渲染，不会传递任何<code class=\"language-text\">props</code>（props变化的情况下一篇blog会讨论）</p>\n</blockquote>\n<p>如果用 <code class=\"language-text\">memo</code>包裹了组件，当父组件重新渲染时，他是不会重新渲染的。</p>\n<p> <video style=\"aspect-ratio: 1360/850\" autoplay=\"\" loop=\"\" muted=\"\" playsinline=\"\" src=\"https://alexsidorenko.com/080d4e7fbda8d86b1b1cae3ef4e68fbe/memo-1-new.mp4\"></video></p>\n<p>注意：<code class=\"language-text\">C</code>组件因为<code class=\"language-text\">state</code>的更新而重新渲染，但是它的父组件B重新渲染后，它并没有重新渲染。</p>\n<h3>提升memo层级</h3>\n<p>把 <code class=\"language-text\">memo</code>的层级向上提升，看看会发生什么</p>\n<p> <video style=\"aspect-ratio: 1360/850\" autoplay=\"\" loop=\"\" muted=\"\" playsinline=\"\" src=\"https://alexsidorenko.com/28677def925378663b692d828e6d63a0/memo-2-new.mp4\"></video></p>\n<p><code class=\"language-text\">A/B/C</code>因为<code class=\"language-text\">state</code>更新导致的重新渲染，结论和之前一样。但是App的重新渲染不影响下面的子组件。结论是：<strong>用<code class=\"language-text\">memo</code>包裹的组件，会阻止它整个子树上的组件因为父组件（也就是这个用memo包裹的组件）更新而导致的重新渲染</strong></p>\n<p>所以你会看到这样的建议：（Contex tProvider组件应该使用<code class=\"language-text\">React.memo</code>）</p>\n<img src=\"https://obs-1d2f.oss-cn-hangzhou.aliyuncs.com/images/image-20210823161114344.png\" alt=\"image-20210823161114344\" style=\"zoom:50%;\">\n<h3>兄弟（相邻）组件如何？</h3>\n<p><video style=\"aspect-ratio: 1360/850\" autoplay=\"\" loop=\"\" muted=\"\" playsinline=\"\" src=\"https://alexsidorenko.com/303d0e491afb2d055835688b36ba24ad/adjacent-new.mp4\"></video></p>\n<p>兄弟组件也符合上面的规则，用 <code class=\"language-text\">memo</code> 包裹的组件不会随着父组件更新而re-render，而且它的子组件树也不会重新渲染。</p>\n<h3>所有的组件都使用<code class=\"language-text\">memo</code>吗</h3>\n<p>假如 <code class=\"language-text\">memo</code>对提高性能有如此之大的效果，那用<code class=\"language-text\">memo</code>来包裹一切组件有意义吗？答案是：并不是。但这个是下一篇Blog要写的东西了。</p>\n<p>此外，所果你有兴趣的话可以阅读一下这篇文章<a href=\"https://kentcdodds.com/blog/fix-the-slow-render-before-you-fix-the-re-render\">Fix the slow render before you fix the re-render</a> （Kent C. Dodds）</p>","frontmatter":{"title":"React Rendering教程（1） - It Always Re-renders","date":"2021/08/23 14:22:28","description":"什么时候React组件会重新渲染？是当它的state或者props改变的时候吗？"}},"previous":{"fields":{"slug":"/react/hooks-principle/"},"frontmatter":{"title":"Hooks的实现原理"}},"next":{"fields":{"slug":"/react/react-render-props/"},"frontmatter":{"title":"React Rendering教程（2） - Props"}}},"pageContext":{"id":"700253a0-4f38-5231-93e4-c980b136bd11","previousPostId":"d25094b8-8d37-5b4a-86f2-792fec3e2c04","nextPostId":"d14a5964-c266-527d-aa77-49405ca39a12"}},"staticQueryHashes":["2355076697","2841359383"]}