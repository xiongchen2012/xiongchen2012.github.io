{"componentChunkName":"component---src-pages-index-js","path":"/","result":{"data":{"site":{"siteMetadata":{"title":"Deathdealer's Blog"}},"allMarkdownRemark":{"nodes":[{"excerpt":"P99 德国，瓦尔特（WALTHER） PX4 Storm 意大利，伯莱塔（BERETTA） HK-USP 德国，黑克勒-科赫（Heckler & Koch） FN Five Seven 比利时，又称57式（噗），赫尔斯塔尔国营工厂（Fabrique Nationale） S&W…","fields":{"slug":"/other/top10-pistol/"},"frontmatter":{"date":"2022/09/14 21:37:32","title":"十大手冲（2022）","description":"2022年的世界Top10手冲"}},{"excerpt":"LDT撸蛋堂（激趣） 和激趣是一个东西，激趣这个牌子是当年撸蛋堂和星角落搞的，星角落已亡 HK416 尼龙齿轮￥528，金属齿轮￥578（原型为德国hk公司hk416d突击步枪） MP5 弹匣版本/弹鼓版本￥628（原型为德国hk公司mp5冲锋枪） 乐辉 MCX ￥76…","fields":{"slug":"/other/guns/"},"frontmatter":{"date":"2022/03/22 21:37:32","title":"合法水弹枪","description":"合法水弹枪"}},{"excerpt":"一月 StateofJS 2020调查结果出炉 Snowpack 3.0发布 React初创成员从Facebook离职 二月 npm 7.0 发布 Vite 2.0发布 三月 Nodejs团队开始思考Nodejs下一个10年的发展规划  jQuery发布3.6.0版本  V…","fields":{"slug":"/basic/javascript_2021_monthbymonth/"},"frontmatter":{"date":"2021/12/24 21:12:13","title":"Javascript2021年大事记","description":"逐月盘点Javascript2021年大事记"}},{"excerpt":"有两种方法打开的语法提示 1. 使用定义 在上面引用webpack的配置定义即可 以下是有效的： 以下是无效的，注意一定要在module.exports上面一行，中间跨越了其它代码就不起作用了。 来自于. 2. 使用Schema文件 这种方式适用于以为配置文件的webpack…","fields":{"slug":"/basic/webpack-hint/"},"frontmatter":{"date":"2021/12/07 13:50:13","title":"webpack.config.js的智能提示","description":"vscode为.babelrc，package.json和jsconfig.json这些文件内置了语法提示，但是webpack却没有内置的语法提示。"}},{"excerpt":"原文地址 https://alexsidorenko.com/blog/react-render-refs 先抛出一个问题：如何在按钮点击3次之后禁用它？（同时前两点击时不能触发re-render）  使用refs…","fields":{"slug":"/react/react-render-refs/"},"frontmatter":{"date":"2021/12/01 19:35:28","title":"React Rendering教程（6） - Refs","description":"不必要的渲染并不总是坏的，但是当你需要优化时，请借助refs来实现你的目的吧。"}},{"excerpt":"EyeDropper API是什么  EyeDropper，没错！吸管工具，凡是做过前端的人都有过安装一个吸管工具用来吸取设计稿中某个颜色值的经历，今后这个工具浏览器会原生支持了，并且提供全套的API供我们使用。 EyeDropper API是 Capabilities…","fields":{"slug":"/basic/eyedropper-api/"},"frontmatter":{"date":"2021/10/30 09:24:13","title":"Introduce to EyeDropper API","description":"本文介绍浏览器原生的吸管API（EyeDropper)的现状和使用"}},{"excerpt":"image-20211009164409456","fields":{"slug":"/typescript/type-vs-interface/"},"frontmatter":{"date":"2021/10/09 16:43:33","title":"Typescript：Type和Interface的异同点","description":"Typescript中type和interface几乎可以混用，但是还是有一些区别的"}},{"excerpt":"原文地址：https://isamatov.com/react-antipatterns，以下是我的翻译 React反模式以及如何避免 以下是React…","fields":{"slug":"/react/react-antipattern/"},"frontmatter":{"date":"2021/10/06 10:33:23","title":"React常见反模式","description":"React常见的反模式，如何避免这些反模式"}},{"excerpt":"原文地址，以下是我的翻译 如果你用过一段时间的React，你一定听说过容器组件和纯展示组件，或是或。这些术语描述了一种将React组件的UI层和业务逻辑分离的模式。 UI层和业务逻辑分离并不是React独有的：关注点分离是一种7…","fields":{"slug":"/react/hooks-separation-of-concerns/"},"frontmatter":{"date":"2021/09/08 16:56:13","title":"用Hooks实现关注点分离","description":"UI层和业务逻辑分离并不是React独有的：关注点分离是一种70年代就存在的设计原则，例如后端通常会把访问数据库的代码和业务逻辑代码进行分离。"}},{"excerpt":"原文地址，下面是我的翻译 摘要 这篇博客，我们将会讨论和学习如何对进行遍历。特别是我们会深入研究一下React提供的方法，它可以确保遍历时的性能和准确性。 前言 React…","fields":{"slug":"/react/children-iteration-methods/"},"frontmatter":{"date":"2021/08/31 23:05:13","title":"React Children Utilities","description":"这篇博客，我们将会讨论和学习如何对React children进行遍历。特别是我们会深入研究一下React提供的React.Children.toArray方法，它可以确保遍历children时的性能和准确性。"}},{"excerpt":"React 就像一个孩子。在搞清楚这个世界的每一件小事之前，它都要向每一个你所解释的 【X是Y】 询问 【Y是什么】 元素是一个用来描述组件实例或 DOM 节点及其需要属性的普通对象 示例： 翻译成element就是： React 元素可以分为两类： DOM类型的元素 DOM…","fields":{"slug":"/react/react-element/"},"frontmatter":{"date":"2021/08/26 16:07:23","title":"React Element","description":"React 就像一个孩子。在搞清楚这个世界的每一件小事之前，它都要向每一个你所解释的 【X是Y】 询问 【Y是什么】"}},{"excerpt":"两种方法 在的回调函数中，可以获取到更新后的值 把放在中调用，可以立马获取到更新的值 重点讲第二种，因为在当前的React版本中还是可以的，未来可能会有问题。 React的三种渲染模式 legacy模式：，当前React使用的模式 blocking…","fields":{"slug":"/react/batched-update/"},"frontmatter":{"date":"2021/08/25 21:43:13","title":"如何获取正确的setState之后的值","description":"从React源码角度看如何正确的获取setState之后的值"}},{"excerpt":"原文地址 当组件消费的时候，如果值变了，组件会重新渲染。但是下面的示例中为什么  and  也重新渲染了？  组件树的结构为  Context和Rendering 第一篇Blog中，我们了解了React Rendering的行为。当组件重新渲染时，React…","fields":{"slug":"/react/react-render-context/"},"frontmatter":{"date":"2021/08/24 15:06:41","title":"React Rendering教程（5） - Context","description":"当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。"}},{"excerpt":"原文地址 我们经常会把匿名函数作为事件处理器传递给React组件。即使子组件被包裹，也会引起子组件的重新渲染  JS…","fields":{"slug":"/react/react-render-usecallback/"},"frontmatter":{"date":"2021/08/24 13:22:02","title":"React Rendering教程（4） - useCallback","description":"我们经常会把匿名函数作为事件处理器传递给React组件。即使子组件被`memo`包裹，也会引起子组件的重新渲染"}},{"excerpt":"原文地址 快速示例： 子组件被 包裹，传递一个给它用于控制是否显示一个侧边栏（当用户的角色更新为”Admin…","fields":{"slug":"/react/react-render-usememo/"},"frontmatter":{"date":"2021/08/23 22:55:23","title":"React Rendering教程（3） - useMemo","description":"useMemo会缓存它的计算结果而不是每次render时都返回一个新的值, 它会返回旧的缓存的值，"}},{"excerpt":"原文地址 子组件用memo包裹时，即使它的props没有变化，父组件重新渲染时为什么它仍然会重新渲染？  JS中有两种类型的值，理解它们的差异可以帮助我们更好的理解组件rendering 原始类型（Primitives） 第一种类型是将原始类型（，，，，，，）作为props…","fields":{"slug":"/react/react-render-props/"},"frontmatter":{"date":"2021/08/23 20:10:28","title":"React Rendering教程（2） - Props","description":"子组件用memo包裹时，即使它的props没有变化，父组件渲染时为什么仍然会重新渲染？"}},{"excerpt":"原文地址 先上图：  先看上图 👆，APP的父子结构是： ，代码如下： 组件A，B，C没有任何和，但是当重新渲染时他们仍然是会重新渲染的。 在正常的渲染过程中，React不会在乎子组件的是不是变化了，它会无条件地重新渲染子组件，因为父组件重新渲染了。 Mark Erikson…","fields":{"slug":"/react/react-render-always-rerenders/"},"frontmatter":{"date":"2021/08/23 14:22:28","title":"React Rendering教程（1） - It Always Re-renders","description":"什么时候React组件会重新渲染？是当它的state或者props改变的时候吗？"}},{"excerpt":"React Hooks: Not MAGIC, Just Arrays useState 的实现原理 先看useState的原型： 的输入是state的初始值，输出始终是一个元组，其中的会被用到，调用除了会设置新的state之外还会更新UI（通过调用函数实现） 绝大部分UI…","fields":{"slug":"/react/hooks-principle/"},"frontmatter":{"date":"2021/08/17 13:48:13","title":"Hooks的实现原理","description":"当使用 Hook 特性编写组件的时候时候，总能感觉到它的简洁和方便。当然，「天下没有免费的午餐」，它牺牲了可读性并且存在内存泄漏风险。但这并不妨碍探索它的魔力。"}},{"excerpt":"问题 默认情况下如果使用  指令去引入Tailwind的 , 和  样式时，会提示：，如下图所示： 虽然不影响最终使用，但是心里还是有个疙瘩。 解决方法 1. 最简单的插件大法 安装插件就可以了，简单粗暴。下载地址 2. Custom Data for CSS Language…","fields":{"slug":"/css/unknown-tailwind-rule/"},"frontmatter":{"date":"2021/08/13 15:55:20","title":"解决VSCode中@tailwind无法解析问题","description":"利用VSCode的css language service解决VSCode中@tailwind无法解析问题，"}},{"excerpt":"名词解释 CSR：Client Side Rendering，客户端渲染（大多数前端开发者集中的领域） SSR：Server Side Rendering，服务端渲染 SSG：Static Site Generation，静态站点生成（我的博客就是） ISR…","fields":{"slug":"/ssr-ssg-isr-dpr/"},"frontmatter":{"date":"2021/08/09 10:14:45","title":"SSR、SSG、ISR、DPR简介","description":"SSR、SSG、ISR、DPR分别是什么，有什么区别，它们是如何一步一步进化的？"}},{"excerpt":"什么是曝光埋点 如果需要衡量流量的分发效率，或者需要衡量活动对用户的吸引力时，会涉及到一个点击效果的量化指标：点击率（CTR…","fields":{"slug":"/intersection-observer/"},"frontmatter":{"date":"2021/07/28 09:52:44","title":"前端埋点之曝光埋点","description":"曝光埋点用来统计页面某个区域被用户“看到”的次数，此外一般还需要加上有效浏览的限制，即该区域至少需要停留时长5s以上"}},{"excerpt":"AJAX 和调用接口的方法一样，基于  封装发送埋点数据的API（不用的原因是考虑XHR兼容性最好），这种方式最简单容易理解，而且使用 POST 方式可以发送的数据量可以很大。缺点是会占用一定的客户端资源，而且需要处理跨域。 服务端跨域设置 Image请求 image…","fields":{"slug":"/data-analysis-track/"},"frontmatter":{"date":"2021/07/27 15:48:03","title":"前端埋点之数据上报方式","description":"前端埋点数据上报到服务器的3种方式:ajax，image,sendBeacon"}},{"excerpt":"XSS 攻击是什么 Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。XSS 攻击通常指的是利用网页的漏洞，攻击者通过巧妙的方法注入 XSS 代码到网页，因为浏览器无法分辨哪些脚本是可信的，导致 XSS 脚本被执行。XSS…","fields":{"slug":"/react/react-xss-protection/"},"frontmatter":{"date":"2021/07/23 09:38:32","title":"XSS攻击的防护（JS）","description":"详解script标签中的defer和aysnc属性"}},{"excerpt":"0x0 背景 经常需要在在引用某个库之前测试一下基本功能和API，又不想创建一个工程去，可以通过以下方支加载CDN上的JS文件 0x1 动态创建Script标签 第三方库的官网上一般会提供npm、直接下载、CDN等几种方式。比如著名的lodash，官网提供的CDN…","fields":{"slug":"/load-libary-console/"},"frontmatter":{"date":"2021/07/21 11:18:23","title":"Chrome控制台加载第三方库","description":"Chrome浏览器的console控台引入外部js文件"}},{"excerpt":"什么是Rebase(变基) 在 Git 中整合来自不同分支的修改主要有两种方法： 以及  , git rebase 和 git merge 作用基本是相同的，二者的一个重要的区别是历史提交本版的区别。git rebase可以使分支看起来像是没有经历过合并一样。 rebase…","fields":{"slug":"/git/git-rebase/"},"frontmatter":{"date":"2021/05/30 09:30:03","title":"常用Git命令速查（4）- Rebase","description":"在Git中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。 本文介绍什么是“变基”，怎样“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。"}},{"excerpt":"什么是HEAD HEAD可以理解为一个指针，HEAD指针通常会指向一个分支（或者说指向一个分支指针），可以通过查看当前的指向 下图很好的表示了的指向 游离HEAD 如果用使用命令  切换分支，HEAD 就会移动到指定的分支上。但是也可以用将HEAD指向某个具体的Commit…","fields":{"slug":"/git/git-detached-head/"},"frontmatter":{"date":"2021/05/27 13:50:03","title":"常用Git命令速查（3）- HEAD游离","description":"详解HEAD为什么会处于游离状态，有什么用，如何脱离游离状态"}},{"excerpt":"背景 团队协作的项目中使用的开源第三方库在使用过程中，如果不能满足业务需求，或是使用过程中发现了该包的bug。可以向原作者提Issue…","fields":{"slug":"/patch-package/"},"frontmatter":{"date":"2021/05/26 14:42:32","title":"团队协作项目中优雅的修改三方库","description":"如果第三方开源库不能满足我们实际项目的需要或者有小BUG等，修改了三方库的源码后如何优雅的与团队成员共享呢？可以使用patch-package修改依赖包内容，为依赖包创建补丁。"}},{"excerpt":"掌握一门语言、框架或工具的人和没有掌握的人之间最大的区别在于他们有没有清晰的心智模型。通过良好的心智模型，你可以直观地理解复杂问题并提出解决方案，而不是一步一步的去寻找答案。 无论你是React的老司机还是新手，拥有一个良好的心智模型是让你成为React…","fields":{"slug":"/a-visual-guide-to-react-mental-models/"},"frontmatter":{"date":"2021/05/25 17:48:03","title":"React心智模型","description":"不同的人以不同的方式学习，但是好的心智模型总是有价值的。"}},{"excerpt":"…","fields":{"slug":"/git/git-rollback/"},"frontmatter":{"date":"2021/05/25 16:14:03","title":"常用Git命令速查（2）- 操作后悔了怎么办？","description":"Git 版本管理时，往往需要撤销某些操作。本文介绍几种最主要的情况，给出详细的解释。"}},{"excerpt":"由于某种不可抗力的因素，国内从microsoft官网下载vscode非常的慢（2021年了却只有几kb/s），甚至无法下载。解决方法如下： 从官网下载VSCode时给的下载服务器域名是： 直接复制这个完整下载路径，保持stable…","fields":{"slug":"/accelerate-vscode-download/"},"frontmatter":{"date":"2021/05/18 11:12:03","title":"国内加速VSCode下载","description":"vscode从微软官网下载非常慢，使用国内azure的镜像下载会大大提速"}},{"excerpt":"Git的基本运作原理图 Git配置 别名 以下是我常用的git别名，就是为了输命令时少打几个字 用户配置 远程仓库操作 克隆 查看远程仓库 添加远程仓库 删除远程仓库 重命名 可以将远程仓库名简单理解为远程地址的缩写 Branch…","fields":{"slug":"/git/git-often-used-cmd/"},"frontmatter":{"date":"2021/05/14 22:34:03","title":"常用Git命令速查（1）- 基本操作","description":"常用Git命令速查"}},{"excerpt":"Picgo部分 Picgo是一个很不错的文件上传工具，支持很多图床：阿里云OSS、腾读云COS、Github、又拍云、七牛云等 picgo和Picgo-Core可以认为是同一个东西，只有命令行 Picgo是用包装后带图形界面的picgo 因为我只是写BLOG…","fields":{"slug":"/typora-aliyunoss/"},"frontmatter":{"date":"2021/04/23 16:50:32","title":"picgo在typora中的配置与使用","description":"使用阿里云OSS作为typora的图床，配置好picgo后自动上传粘贴到typora中的图片"}},{"excerpt":"Props 和react等框架一样，svelte也是通过向子组件传值。不一样的是，在svelte中，子组件需要用来标记接收props的变量。这里的和js模块里面的export用法完全不一样，看起来很怪异，但是在Svelte中暂时需要去习惯它 父组件传值和react…","fields":{"slug":"/svelte/svelte-3/"},"frontmatter":{"date":"2021/04/18 21:41:32","title":"Svelte学习笔记（3）","description":"自学Svelte时的学习笔记第3篇，方便自己以后快速复习"}},{"excerpt":"响应式系统 Svelte’s reactivity is based on assignments Svelte的响应式系统是基于赋值的，只要给声明的变量、对象、数组重新赋值，就可以触发re-render…","fields":{"slug":"/svelte/svelte-2/"},"frontmatter":{"date":"2021/04/18 21:33:32","title":"Svelte学习笔记（2）","description":"自学Svelte时的学习笔记第2篇，方便自己以后快速复习"}},{"excerpt":"Svelte是什么 首先它又是一个做Web开发的轮子，在State Of JS 2020调查中Svelte获得前端工程师的一致好评，是2020年满意度第1的前端框架。 Svelte is a radical new approach to building user…","fields":{"slug":"/svelte/svelte-1/"},"frontmatter":{"date":"2021/04/18 21:25:32","title":"Svelte学习笔记（1）","description":"自学Svelte时的学习笔记第1篇，方便自己以后快速复习"}},{"excerpt":"又一个状态管理的轮子。查了一下字典在芬兰语里面就是的意思，名字起的真是简单粗暴（作者却是个日本人） 安装 使用 1. 基本使用 官方文档宣称可以让对象拥有自我意识（实际上还是基于Proxy进行对原对象进行了代理） 然后就可以在任何地方、像普通的js对象一样直接修改值（Mutate…","fields":{"slug":"/intro-valtio/"},"frontmatter":{"date":"2021/03/23 22:46:32","title":"valtio简介","description":"介绍一种类似于immer但是使用更简单的状态管理库valtio"}},{"excerpt":"一张图很好的说明了区别： 普通script标签 遇到script 标签会中断 HTML 的解析，然后开始下载脚本并执行，执行完成后继续 HTML 和解析 带defer属性的script标签  遇到带 defer 属性的 script…","fields":{"slug":"/script-defer-async/"},"frontmatter":{"date":"2021/03/22 22:40:32","title":"script标签中的defer和async","description":"详解script标签中的defer和aysnc属性"}},{"excerpt":"总结 方法 一句话总结 Promise.all 全部的全部才能resolve，只要有一个就直接了 Promise.allSettled 要等到所有promise都已敲定（settled），即每个promise都要或 Promise.any 只要promise…","fields":{"slug":"/basic/promise-static-methid/"},"frontmatter":{"date":"2021/03/21 13:48:13","title":"Promise的静态方法","description":"整理Promise所有静态方法"}},{"excerpt":"TLDR https://www.zhihu.com/question/20348948/answer/1486703…","fields":{"slug":"/basic/compare-variables/"},"frontmatter":{"date":"2020/09/21 13:48:13","title":"使用===和==的建议","description":"什么时候使用===（严格比较），什么时候使用==（宽松比较，抽象比较）"}}]}},"pageContext":{}},"staticQueryHashes":["2355076697","2841359383"]}