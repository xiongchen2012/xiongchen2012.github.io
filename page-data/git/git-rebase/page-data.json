{"componentChunkName":"component---src-templates-blog-post-js","path":"/git/git-rebase/","result":{"data":{"site":{"siteMetadata":{"title":"Deathdealer's Blog"}},"markdownRemark":{"id":"301949e1-1ea5-5061-973b-2278dcb90f4e","excerpt":"什么是Rebase(变基) 在 Git 中整合来自不同分支的修改主要有两种方法： 以及  , git rebase 和 git merge 作用基本是相同的，二者的一个重要的区别是历史提交本版的区别。git rebase可以使分支看起来像是没有经历过合并一样。 rebase merge…","html":"<h4>什么是Rebase(变基)</h4>\n<p>在 Git 中整合来自不同分支的修改主要有两种方法：<code class=\"language-text\">merge</code> 以及 <code class=\"language-text\">rebase</code> , git rebase 和 git merge 作用基本是相同的，二者的一个重要的区别是历史提交本版的区别。git rebase可以使分支看起来像是没有经历过合并一样。</p>\n<ul>\n<li>\n<p>rebase</p>\n<img src=\"https://obs-1d2f.oss-cn-hangzhou.aliyuncs.com/images/image-20210609203440812.png\" alt=\"image-20210609203440812\" style=\"zoom:45%;\">\n</li>\n<li>\n<p>merge</p>\n<img src=\"https://obs-1d2f.oss-cn-hangzhou.aliyuncs.com/images/image-20210609203516904.png\" alt=\"image-20210609203516904\" style=\"zoom:35%;\">\n</li>\n</ul>\n<h5>使用 <code class=\"language-text\">rebase</code> 和 <code class=\"language-text\">merge</code> 的基本原则：</h5>\n<ol>\n<li>下游分支更新上游分支内容的时候使用 <code class=\"language-text\">rebase</code></li>\n<li>上游分支合并下游分支内容的时候使用 <code class=\"language-text\">merge</code></li>\n</ol>\n<p>例如现有上游分支 master，基于 master 分支拉出来一个开发分支 dev，在 dev 上开发了一段时间后要把 master 分支提交的新内容更新到 dev 分支，此时切换到 dev 分支，使用 <code class=\"language-text\">git rebase master</code></p>\n<p>等 dev 分支开发完成了之后，要合并到上游分支 master 上的时候，切换到 master 分支，使用 <code class=\"language-text\">git merge dev</code></p>\n<h4>Rebase使用场景一：合并提交记录</h4>\n<p>每次功能迭代开发，最终对多个 commit 进行合并处理，例如，合并最近的 n 次提交纪录，执行：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">$ <span class=\"token function\">git</span> rebase -i HEAD~n</code></pre></div>\n<p>这时候，会自动进入 <code class=\"language-text\">vi</code> 编辑模式：</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">pick cacc52da add: qrcode\npick f072ef48 update: indexeddb hack\npick 4e84901a feat: <span class=\"token function\">add</span> indexedDB floder\npick 8f33126c feat: <span class=\"token function\">add</span> test2.js\n\n<span class=\"token comment\"># Rebase 5f2452b2..8f33126c onto 5f2452b2 (4 commands)</span>\n<span class=\"token comment\">#</span>\n<span class=\"token comment\"># Commands:</span>\n<span class=\"token comment\"># p, pick = use commit</span>\n<span class=\"token comment\"># r, reword = use commit, but edit the commit message</span>\n<span class=\"token comment\"># e, edit = use commit, but stop for amending</span>\n<span class=\"token comment\"># s, squash = use commit, but meld into previous commit</span>\n<span class=\"token comment\"># f, fixup = like \"squash\", but discard this commit's log message</span>\n<span class=\"token comment\"># x, exec = run command (the rest of the line) using shell</span>\n<span class=\"token comment\"># d, drop = remove commit</span>\n<span class=\"token comment\">#</span>\n<span class=\"token comment\"># These lines can be re-ordered; they are executed from top to bottom.</span>\n<span class=\"token comment\">#</span>\n<span class=\"token comment\"># If you remove a line here THAT COMMIT WILL BE LOST.</span>\n<span class=\"token comment\">#</span>\n<span class=\"token comment\"># However, if you remove everything, the rebase will be aborted.</span></code></pre></div>\n<p>把前面的pick改成squash就可以合并记录，注意：</p>\n<blockquote>\n<p>不要合并先前提交的东西，也就是已经提交远程分支的纪录。</p>\n</blockquote>\n<p>后续可以用<code class=\"language-text\">rebase --abort</code>放弃变基，<code class=\"language-text\">rebase --edit-todo</code>重新进入编辑模式，<code class=\"language-text\">rebase --continue</code>解变基冲突后继续</p>\n<h4>Rebase 使用场景二：分支合并</h4>\n<p>主要用于从上游分支合并代码到当前分支，比如从<code class=\"language-text\">master</code>拉来的个人开发分支<code class=\"language-text\">feature</code>，但是另外的同事对master进行了hotfix，此时你刚好急需把hotfix的代码拉到自己的特性分支上。如果用merge是没有问题的，不过会产生一条<code class=\"language-text\">merge commit</code>，污染特性分支的commit log，这时候可以用rebase来进行合并。</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">$ <span class=\"token function\">git</span> rebase master</code></pre></div>\n<p>一面一条命令会依次：</p>\n<ol>\n<li><code class=\"language-text\">git</code> 会把 <code class=\"language-text\">feature</code> 分支里面的每个 <code class=\"language-text\">commit</code>都先取消掉；</li>\n<li>把上面的操作临时保存成 <code class=\"language-text\">patch</code> 文件，存在 <code class=\"language-text\">.git/rebase</code> 目录里；</li>\n<li>从<code class=\"language-text\">master</code>把最新代码更新到 <code class=\"language-text\">feature</code> 分支上；</li>\n<li>把上面保存的 <code class=\"language-text\">patch</code> 文件应用到 <code class=\"language-text\">feature1</code> 分支上；</li>\n</ol>\n<p>这样过后，最新代码也有了，commit记录也是完美继承过来，不会产生<code class=\"language-text\">merge commit</code></p>\n<h4>Rebase的风险</h4>\n<p>呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：</p>\n<blockquote>\n<p><strong>如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。</strong></p>\n</blockquote>\n<p>换句话说：除非你可以肯定该需要变基的分支只有你自己使用，否则请谨慎操作。</p>\n<p>再换句话说：只要你的分支上需要 <code class=\"language-text\">rebase</code> 的所有 <code class=\"language-text\">commits</code> 历史还没有被 <code class=\"language-text\">push</code> 过，就可以安全地使用 <code class=\"language-text\">git-rebase</code>来操作</p>","frontmatter":{"title":"常用Git命令速查（4）- Rebase","date":"2021/05/30 09:30:03","description":"在Git中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。 本文介绍什么是“变基”，怎样“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。"}},"previous":{"fields":{"slug":"/git/git-detached-head/"},"frontmatter":{"title":"常用Git命令速查（3）- HEAD游离"}},"next":{"fields":{"slug":"/load-libary-console/"},"frontmatter":{"title":"Chrome控制台加载第三方库"}}},"pageContext":{"id":"301949e1-1ea5-5061-973b-2278dcb90f4e","previousPostId":"c0b7d143-9cb1-5c0f-b5ae-70ccc210264c","nextPostId":"821e3ea7-7b4f-57e2-92f5-21c7d3735cd7"}},"staticQueryHashes":["2355076697","2841359383"]}